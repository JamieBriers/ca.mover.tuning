#!/bin/bash
#Copyright 2005-2017, Lime Technology
#License: GPLv2 only

# This is the 'mover tuning' script used for moving files between the cache disk and main array.
# It is typically invoked via cron.

# First we check if it's valid for this script run: there must be a cache disk present and
# an instance of the script must not already be running.

# Next, check each of the top-level directories (shares) on the cache disk.
# For all share with 'Use Cache' setting set to "prefer" or "yes", we use 'find' to
# create a filtered file list of that share directory.
# For all share with 'Use Cache' setting set to "only", we use 'du' or 'zfs list' to
# get total size of that share directory.

# The list is sorted by "Use cache", increasing age, pool, and file inode, giving priority for being 
# on cache to "cache only" shares, then "cache prefer" by moving newest from array to cache and older to array, 
# and finally to "cache yes" share by moving only from cache to array.
# Please note that if age setting is set to something else than "Auto (smart cache)" this script is actually
# dumb and do not check for size and free space and rely on your own calculations.
# Files at the top level of the cache or an array disk (i.e not in a share) are never moved.

# The list is then passed to original unraid mover.
# For each file, if the file is not "in use" by any process (as detected by 'fuser' command),
# then the file is moved, and upon success, deleted from the source disk.  If the file already
# exists on the target, it is not moved and the sourceis not deleted.  All meta-data of moved
# files/directories is preserved: permissions, ownership, extended attributes, and access/modified
# timestamps.

# If an error occurs in copying a file, the partial file, if present, is deleted and the
# operation continues on to the next file.

PIDFILE="/var/run/mover.pid"
SOFTSTOPFILE="/var/run/moversoft.stop"
UNRAIDCFGFILE="/boot/config/share.cfg"
MOVERTUNINGCFGFILE="/boot/config/plugins/ca.mover.tuning/ca.mover.tuning.cfg"
LOGLEVEL=1
TOTALCACHEFILES=0
REMAININGCACHEFILES=0
TOTALCACHESIZE=0
REMAININGCACHESIZE=0
TOTALARRAYFILES=0
REMAININGARRAYFILES=0
TOTALARRAYSIZE=0
REMAININGARRAYSIZE=0
NOW=$(date +"%FT%H%M%S")
FILTERED_FILELIST="/tmp/ca.mover.tuning/Filtered_files_$NOW.list"
MOVER_ACTIONLIST="/tmp/ca.mover.tuning/Mover_action_$NOW.list"
STATS_FILE="/tmp/ca.mover.tuning/Summary_$NOW.txt"
MOVER_STATUS="/usr/local/emhttp/state/mover.ini"
MOVER_LOG="/tmp/ca.mover.tuning/Mover_tuning_$NOW.log"
GUI_CURRENT_FILE=""
GUI_ACTION="Calculating"

function is_zfs_mountpoint_fstype() {
    local result
    result=$(findmnt $1 -o fstype | tail -n 1)
    [ "$result" = "zfs" ]
    return
}

function titleLine() {
  local title="$1"
  local padding_char="$2"
  local line_length=71
  local padding_left=$((line_length - ${#title} / 2))
  local padding_right=$(( padding_left - ${#title} % 2 -1 ))
  local left_padding=$(printf "%*s" "$padding_left" | tr ' ' "$padding_char")
  local right_padding=$(printf "%*s" "$padding_right" | tr ' ' "$padding_char")
  echo "${left_padding}$padding_char $title $padding_char${right_padding}"
}

# Function to convert byte size to human-readable format
function convert_bytes() {
  local byte_size="$1"
  local suffixes=("B" "KiB" "MiB" "GiB" "TiB" "PiB" "EiB" "ZiB" "YiB")
  local i=0

  if [ byte_size = 0 ]; then
    printf "%d %s\n" "$byte_size" "${suffixes[i]}"
    return 0
  fi

  while (( byte_size >= 1024 )); do
    (( byte_size /= 1024 ))
    (( ++i ))
  done

  printf "%d %s\n" "$byte_size" "${suffixes[i]}"
}

# Function for verbose output and logging
mvlogger() {

    if [ ! -d "/tmp/ca.mover.tuning" ]; then
        echo "/tmp/ca.mover.tuning Directory does not exist. Creating it"
        mkdir -p /tmp/ca.mover.tuning
    fi

    if [ $LOGLEVEL = 1 ]; then
        if [ -t 1 ]; then # running from terminal, echoing date
            echo "$(date +"%T.%3N") $1"
        else # running from cron
            echo "$1"
        fi
    fi
    echo "$(date +"%T.%3N") $1" >>$MOVER_LOG
}

#Moved variable assignment into a function
getMoverSettings() {
    #Use the config file instead of input variables (ease execution from command line)
    local config_file="$1"
    cfg() {
        local param="$1"
        local value
        while IFS='=' read -r key val; do
        [ "$key" == "$param" ] && { value="$val"; break; }
        done < "$config_file"
        echo "${value//\"/}"  # Print value or empty string if not found, without quotes
    }

    if [[ ! -f "$config_file" ]]; then
        mvlogger "Error: Config file '$config_file' not found."
        return 1
    fi

    ## Read in default threshold limit.
    ## [[ ! "$config_file" =~ shareOverrideConfig ]] && ensure that we are not reading share custom settings
    
    [[ ! "$config_file" =~ shareOverrideConfig ]] && DFTPCTLIMIT=$(cfg threshold)
    [[ ! "$config_file" =~ shareOverrideConfig ]] && mvlogger "Default threshold: $DFTPCTLIMIT %"

    # Read other thresholds
    if [ $(cfg omovercfg) != "yes" ]; then
        #mvlogger "No Original Mover Threshold Percent Supplied"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && OMOVERTHRESH=""
    else
        OMOVERTHRESH=$(cfg omoverthresh)
        [ ! -z $OMOVERTHRESH ] && mvlogger "Cache threshold to Move all Cache-Yes shares to array: $OMOVERTHRESH %"
    fi
    if [ -z $(cfg shareThreshold) ]; then
        SHAREPCTLIMIT="NA"
    else
        SHAREPCTLIMIT=$(cfg shareThreshold)
        mvlogger "Share threshold: $SHAREPCTLIMIT %"
    fi
    
    # Read filters parameters
    if [ -z $(cfg age) ]; then
        [[ ! "$config_file" =~ shareOverrideConfig ]] && mvlogger "No Age argument supplied"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && AGE=0
    else
        if [ $(cfg age) = "yes" ]; then
            AGE=$(cfg daysold)
            if [ $AGE -eq -1 ]; then 
                mvlogger "Age: Automatic (smart caching)"
            else
                mvlogger "Age: $AGE"
            fi
        else
            AGE=0
            mvlogger "Age: $(cfg age) = $AGE ; daysold: $(cfg daysold)"
        fi
    fi

    if [ -z $(cfg afterScript) ]; then
        #mvlogger "No After Script argument supplied"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && AFTERSCRIPT=""
    else
        AFTERSCRIPT=$(cfg afterScript)
        mvlogger "After script: $AFTERSCRIPT"
    fi

    if [ -z $(cfg beforeScript) ]; then
        #mvlogger "No Before Script argument supplied"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && BEFORESCRIPT=""
    else
        BEFORESCRIPT=$(cfg beforeScript)
        mvlogger "Before script: $BEFORESCRIPT"
    fi

    if [ -z $(cfg ctime)  ]; then
        [[ ! "$config_file" =~ shareOverrideConfig ]] && mvlogger "No CTIME argument supplied"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && CTIMEA=""
    else
        CTIMEA=$(cfg ctime)
        [ $CTIMEA = "yes" ] && mvlogger "CTIME: $CTIMEA"
    fi

    if [ -z $(cfg enableTurbo) ]; then
        [[ ! "$config_file" =~ shareOverrideConfig ]] && mvlogger "No Turbo Mode argument supplied"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && ENABLETURBO=""
    else
        ENABLETURBO=$(cfg enableTurbo)
        [ $ENABLETURBO = "yes" ] && mvlogger "Enable Turbo: $ENABLETURBO"
    fi

    if [ -z $(cfg filelistf) ]; then
        [[ ! "$config_file" =~ shareOverrideConfig ]] && mvlogger "No Skipfiles argument supplied"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && SKIPFILESLIST=""
        [[ ! "$config_file" =~ shareOverrideConfig ]] && SKIPFOLDERSLIST=""
    else
        if [ $(cfg filelistf) = "yes" ]; then
            SKIPFILESPATH=$(cfg filelistv)
            SKIPFILESPATH=$(echo $SKIPFILESPATH | sed 's/ *$//g')
            SKIPFILESLIST=$SKIPFILESPATH
            SKIPFOLDERSLIST=""
            while IFS= read -r path; do
                path=${path%/}
                if [ -d "$path" ]; then
                    SKIPFOLDERSLIST+="$path/*"$'\n'
                fi
            done < <(cat "$SKIPFILESPATH"; echo)
            SKIPFOLDERSLIST="${SKIPFOLDERSLIST%$'\n'}"
            mvlogger "Skip file list path: $SKIPFILESLIST"
            mvlogger "Skip folder list path: $SKIPFOLDERSLIST"
        else
            SKIPFILESLIST=""
            SKIPFOLDERSLIST=""
        fi
    fi

    if [ -z $(cfg filetypesf) ]; then
        [[ ! "$config_file" =~ shareOverrideConfig ]] && mvlogger "No Skip File Types argument supplied"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && SKIPFILETYPES=""
    else
        if [ $(cfg filetypesf) = "yes" ]; then
            ###echo "Skipfiletypes supplied"
            SKIPFILETYPES=$(cfg filetypesv)
            SKIPFILETYPES=$(echo "$SKIPFILETYPES" | awk -F, '{for(i=1;i<=NF;i++) {gsub(/ /, "", $i); if ($i !~ /^\./) $i = "."$i; printf "%s%s", $i, (i<NF?",":"")}}')
            mvlogger "Skip filetypes: $SKIPFILETYPES"
        else
            SKIPFILETYPES=""
        fi
    fi

    if [ -z $(cfg ignoreHidden) ]; then
        [[ ! "$config_file" =~ shareOverrideConfig ]] && mvlogger "No Ignore Hidden Files argument supplied"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && HIDDENFILES=""
    else
        HIDDENFILES=$(cfg ignoreHidden)
        [ $HIDDENFILES = "yes" ] && mvlogger "Ignore Hidden Files: $HIDDENFILES"
    fi
    
    if [ -z $(cfg repairPrimary) ]; then
        [[ ! "$config_file" =~ shareOverrideConfig ]] && mvlogger "No Repair argument provided"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && REPAIRPRIMARYSHARES=""
    else
        REPAIRPRIMARYSHARES=$(cfg repairPrimary)
        [ $REPAIRPRIMARYSHARES = "yes" ] && mvlogger "Repair Cache:Only and Cache:No Shares: $REPAIRPRIMARYSHARES"
    fi

    if [ -z $(cfg sizef) ]; then
        [[ ! "$config_file" =~ shareOverrideConfig ]] && mvlogger "No Size argument supplied"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && SIZE=0
    else
        if [ $(cfg sizef) = "yes" ]; then
            SIZE=$(cfg sizeinM)
            [ $SIZE -gt 0 ] && mvlogger "Size supplied: $SIZE"
        else
            SIZE=0
        fi
    fi

    if [ -z $(cfg sparsnessf) ]; then
        [[ ! "$config_file" =~ shareOverrideConfig ]] && mvlogger "No Sparness argument supplied"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && SPARSENESS=0
    else
        if [ $(cfg sparsnessf) = "yes" ]; then
            SPARSENESS=$(cfg sparsnessv)
            [ $SPARSENESS - gt 0 ] && mvlogger "Sparness supplied: $SPARSENESS"
        else
            SPARSENESS=0
        fi
    fi

    if [ -z $(cfg synchronizeCache) ]; then
        [[ ! "$config_file" =~ shareOverrideConfig ]] && mvlogger "No Synchronize Cache argument provided"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && SYNCHRONIZECACHE=""
    else
        SYNCHRONIZECACHE=$(cfg synchronizeCache)
        if [ $SYNCHRONIZECACHE = "yes" ]; then
            LASTCACHESYNC=$(cfg lastCacheSync)
            [ -z $LASTCACHESYNC ] && LASTCACHESYNC=0
            mvlogger "Synchronize cache: $SYNCHRONIZECACHE"
        fi
    fi

    if [ -z $(cfg testmode) ]; then
        [[ ! "$config_file" =~ shareOverrideConfig ]] && mvlogger "No Test Mode argument supplied"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && TESTMODE=""
    else
        TESTMODE=$(cfg testmode)
        [ $TESTMODE = "yes" ] && mvlogger "Test Mode: $TESTMODE"
    fi
}

moverStatusWrite() {
    #echo "test write"
    #Writes to file /usr/local/emhttp/state/mover.ini GUI update variables
    echo "TotalToArray=${TOTALCACHESIZE}" >$MOVER_STATUS
    echo "RemainToArray=${REMAININGCACHESIZE}" >>$MOVER_STATUS
    echo "TotalFromArray=${TOTALARRAYSIZE}" >>$MOVER_STATUS
    echo "RemainFromArray=${REMAININGARRAYSIZE}" >>$MOVER_STATUS
    echo "TotalFilesToArray=${TOTALCACHEFILES}" >$MOVER_STATUS
    echo "RemainFilesToArray=${REMAININGCACHEFILES}" >>$MOVER_STATUS
    echo "TotalFilesFromArray=${TOTALARRAYFILES}" >>$MOVER_STATUS
    echo "RemainFilesFromArray=${REMAININGARRAYFILES}" >>$MOVER_STATUS
    echo "File=${GUI_CURRENT_FILE}" >>$MOVER_STATUS
    echo "Action=${GUI_ACTION}" >>$MOVER_STATUS
}

createFilteredFilelist (){
    mvlogger "$(titleLine 'FILTERING FILES' '*')"
    # create a file containing the list off all shareUseCache yes or prefer whith this format:
    echo "CACHEPOOLNAME|SHARENAME|SHAREUSECACHE|MODIFICATIONTIME|CACHESIZETRESH|FILESIZE|NBLINKS|INODE|FILEPATH" > $FILTERED_FILELIST
    for SHARECFG in /boot/config/shares/*; do
        overrideFlag=0
        globalSkipFileTypes=$SKIPFILETYPES

        #Start Creating the Find String.
        #Sharename
        SHARENAME="$(basename "$SHARECFG" .cfg)"
        mvlogger "$(titleLine "Settings for $SHARENAME share" '-')"
        #Check to see if this share has a mover settings override, if yes set overrideFlag and change settings
        if [ -f "/boot/config/plugins/ca.mover.tuning/shareOverrideConfig/$SHARENAME.cfg" ]; then
            SHARETUNINGFILE="/boot/config/plugins/ca.mover.tuning/shareOverrideConfig/$SHARENAME.cfg"
            if grep -qs 'moverOverride="yes"' $SHARETUNINGFILE; then
                overrideFlag=1
                mvlogger  "Settings override:"
                mvlogger  "------------------"
                getMoverSettings $SHARETUNINGFILE
                mvlogger "$(titleLine "" '-')"
            fi
        fi

        #Cachepoolname
        CACHEPOOLNAME=$(grep shareCachePool "$SHARECFG" | cut -d'=' -f 2 | tr -d '"' | tr -d '\r')
        if [ -z "$CACHEPOOLNAME" ]; then
            mvlogger "No shareCachePool entry found in config file, defaulting to cache"
            CACHEPOOLNAME="cache"
        fi

        # Determine Cache mode
        SHAREUSECACHE=$(grep shareUseCache "$SHARECFG" | cut -d'=' -f 2 | tr -d '"' | tr -d '\r')

        # Set Share path. If a "cache=prefer" pool, we list files in /mnt/user and process later
        if [ "$SHAREUSECACHE" = "prefer" ]; then
            mvlogger "Cache mode: Prefer/Array->Cache. Will smart move newest files from Array to Cache until threshold. Older files will be moved from Cache to Array."
            SHAREPATH="/mnt/user/$SHARENAME"
        else
            SHAREPATH="/mnt/$CACHEPOOLNAME/$SHARENAME"
        fi
        # Give information according to cache mode
        if [ $SHAREUSECACHE = "only" ] && [ $REPAIRPRIMARYSHARES = "no" ]; then
            mvlogger "Cache mode: Only. Nothing will be moved. Its usage is taken into account in the calculation of the threshold." 
        elif [ $SHAREUSECACHE = "only" ] && [ $REPAIRPRIMARYSHARES = "yes" ]; then
            mvlogger "Cache mode: Only. Eventual files on array will be moved to cache as redistribute cache only/no shares option is selected"
        elif [ $SHAREUSECACHE = "yes" ]; then
            mvlogger "Cache mode: Yes/Cache->Array. Will smart move old files from Cache to Array. Nothing will be moved from Array to Cache"
        elif [ $SHAREUSECACHE = "no" ] && [ $REPAIRPRIMARYSHARES = "no" ]; then
            mvlogger "Cache mode: No. Skipping"
            continue
        elif [ $SHAREUSECACHE = "no" ] && [ $REPAIRPRIMARYSHARES = "yes" ]; then
            mvlogger "Cache mode: No. Eventual files on cache will be moved to array as redistribute cache only/no shares option is selected"
        fi
        mvlogger "Share Information: Name: $SHARENAME - Path: $SHAREPATH - Cache mode: $SHAREUSECACHE"
        
        # Do not process this pool if Share path is /mnt/cache
        if [ "$SHAREPATH" = "/mnt/cache" ]; then
            mvlogger "Skipping processing for /mnt/cache"
            continue  # Move to the next iteration of the loop
        fi

        #Find the current percent of used size of pool.
        if is_zfs_mountpoint_fstype "/mnt/$CACHEPOOLNAME"; then
            #mvlogger "$CACHEPOOLNAME is zfs."
            POOLPCTUSED=$(zpool get -o value capacity $CACHEPOOLNAME | tail -n 1 | tr -d '%')
            POOLBYTEUSED=$(zfs list -Hpo used $CACHEPOOLNAME )
        else
            POOLPCTUSED=$(df --output=pcent /mnt/$CACHEPOOLNAME | tail -n 1 | tr -d '%')
            POOLBYTEUSED=$(df --output=used --block-size=1 /mnt/$CACHEPOOLNAME | tail -n 1)
        fi
        mvlogger "Pool Information: Name: $CACHEPOOLNAME - pool used: $POOLPCTUSED % - size: $POOLBYTEUSED bytes ($(convert_bytes $POOLBYTEUSED))"
        
        #Determine which percent limit we are going to use, in case ca.mover.tuning.cfg does not have a cachepool percent limit entry.
        if [ "$SHAREPCTLIMIT" = "NA" ]; then
            SELECTEDTHRESHOLD=$DFTPCTLIMIT
        else
            SELECTEDTHRESHOLD=$SHAREPCTLIMIT
        fi
        if [ "$OMOVERTHRESH" != "" ] && [ $POOLPCTUSED -gt $OMOVERTHRESH ] && [ $SHAREUSECACHE = "yes" ]; then
            mvlogger "Pool is above 'move all' percentage: $OMOVERTHRESH % => moving all cache-yes shares to array"
            CACHESIZETHRESH=0
        else        
            #Get the size threshold in bytes
            if is_zfs_mountpoint_fstype "/mnt/$CACHEPOOLNAME"; then
                CACHESIZETHRESH=$(( $(zfs list -Hp -o available,used $CACHEPOOLNAME | awk '{print $1 + $2}') * $SELECTEDTHRESHOLD /100))
            else
                CACHESIZETHRESH=$(( $(df --output=size --block-size=1 /mnt/$CACHEPOOLNAME | tail -n 1) * $SELECTEDTHRESHOLD /100))
            fi
            #Get reserved space. This is the space used by cache only shares.
            if [ $SHAREUSECACHE = "only" ] && [ $REPAIRPRIMARYSHARES = "no" ]; then
                if is_zfs_mountpoint_fstype "/mnt/$CACHEPOOLNAME"; then
                    CACHESHARERESERVEDSPACE=$(zfs list -Hpo used $CACHEPOOLNAME/$SHARENAME )
                else
                    CACHESHARERESERVEDSPACE=$(du -b -d0 $SHAREPATH | awk '{print $1}')
                fi
                echo "${CACHEPOOLNAME}|$SHARENAME|only|9999999999|$CACHESIZETHRESH|$CACHESHARERESERVEDSPACE|0|0|0|$SHAREPATH" >>$FILTERED_FILELIST
                mvlogger "$CACHEPOOLNAME/$SHARENAME usage: $CACHESHARERESERVEDSPACE bytes ($(convert_bytes $CACHESHARERESERVEDSPACE))"
            elif [ $SHAREUSECACHE != "only" ]; then
                mvlogger "Default threshold: $DFTPCTLIMIT % - $SHARENAME share threshold: $SHAREPCTLIMIT % => Threshold selected: $SELECTEDTHRESHOLD %,s size: $CACHESIZETHRESH bytes ($(convert_bytes $CACHESIZETHRESH))"
            fi
        fi        

        #Base Find String
        FINDSTR="find \"$SHAREPATH\" -type f -depth"

        #Addition of filters are conditionned by [ $CACHESIZETHRESH -gt 0 ] to prevent filtering move all cache-yes share
        #Add Age variables to find string
        if [ $CACHESIZETHRESH -gt 0 ] && [ "$AGE" -ge 1 ]; then
            mvlogger "Adding Age"
            RAGE=$((AGE - 1))
            # Use Creation time or modification time according to settings
            if [ "$CTIMEA" == "yes" ]; then
                mvlogger "Age (creation time) ${AGE}"
                FINDSTR+=" -ctime +$RAGE"
            else
                mvlogger "Age (modification time) ${AGE}"
                FINDSTR+=" -mtime +$RAGE"
            fi
        fi


        #Get the size threshold in bytes
        if is_zfs_mountpoint_fstype "/mnt/$CACHEPOOLNAME"; then
            CACHESIZETHRESH=$(( $(zfs list -Hp -o available,used $CACHEPOOLNAME | awk '{print $1 + $2}') * $SELECTEDTHRESHOLD /100))
        else
            CACHESIZETHRESH=$(( $(df --output=size --block-size=1 /mnt/$CACHEPOOLNAME | tail -n 1) * $SELECTEDTHRESHOLD /100))
        fi

        #Add Size to find string
        if [ $CACHESIZETHRESH -gt 0 ] && [ "$SIZE" -gt 0 ]; then
            mvlogger "Adding Size: ${SIZE}"
            FINDSTR+=" -size +${SIZE}M"
        fi


        #Add Ignore Hidden Files to find string
        if [ $CACHESIZETHRESH -gt 0 ] && [ "$HIDDENFILES" == "yes" ]; then
            mvlogger "Adding Ignore Hidden Files: ${HIDDENFILES}"
            FINDSTR+=" -not -path '*/\.*'"
        fi

        if [ $CACHESIZETHRESH -gt 0 ] && [ -n "$SKIPFOLDERSLIST" ]; then
            mvlogger "Adding Skip Folder List. List Path: ${SKIPFILESPATH}"
            while IFS= read -r folder; do
                FINDSTR+=" -not -path '${folder}'"
            done <<<"$SKIPFOLDERSLIST"
        fi

        #Add Size to find string
        FINDSTR+=" -printf '%T@|%s|%S|%n|%i|%p|\0' | awk -v RS='\0' -v FS='|' -v SPARSENESS=\$SPARSENESS -v CACHEPOOLNAME=\$CACHEPOOLNAME -v SHARENAME=\$SHARENAME -v SHAREUSECACHE=\$SHAREUSECACHE -v CACHESIZETHRESH=\$CACHESIZETHRESH"
        if [ $CACHESIZETHRESH -gt 0 ] && [ "$SPARSENESS" -gt 0 ]; then
            mvlogger "Adding Sparseness size ${SPARSENESS}"
            FINDSTR+="' \$3 > 0.SPARSENESS '"
        else
            FINDSTR+=" '"
        fi
        if [ "$CTIMEA" == "yes" ]; then
            FINDSTR+="{printf \"%s|%s|%s|%d|%d|%d|%s|%d|%d|%s\\n\", CACHEPOOLNAME, SHARENAME, SHAREUSECACHE, \$1, CACHESIZETHRESH, \$2, \$3, \$4, \$5, \$6}'"
        else
            FINDSTR+="{cmd=\"stat -c%Y \\\"\"\$6\"\\\"\"; cmd | getline result; close(cmd); sub(/\\n\$/, \"\", result); printf \"%s|%s|%s|%d|%d|%d|%s|%d|%d|%s\\n\", CACHEPOOLNAME, SHARENAME, SHAREUSECACHE, result, CACHESIZETHRESH, \$2, \$3, \$4, \$5, \$6}'"
        fi

        #Add additional commands
        #Add Skipfilelist to find string
        if [ $CACHESIZETHRESH -gt 0 ] && [ -n "$SKIPFILESLIST" ]; then
            mvlogger "Adding Skip File List. List Path: ${SKIPFILESPATH}"

            FINDSTR+=" | grep -vFx -f <(sed 's/\/*$//' '$SKIPFILESLIST')"
            mvlogger "Skipfilelist string: $FINDSTR"
        fi

        if [ $CACHESIZETHRESH -gt 0 ] && [ -n "$SKIPFILETYPES" ]; then
            FINDSTR+=" | grep -iv"
            for i in $(echo $SKIPFILETYPES | sed "s/,/ /g"); do
                FINDSTR+=" -e '\\$i'"
            done
            mvlogger "Skipfiletypes string: $FINDSTR"
        fi
        
        if [ $CACHESIZETHRESH -gt 0 ] && [ $overrideFlag = 1 ] && [ -n "$globalSkipFileTypes" ]; then
            FINDSTR+=" | grep -iv"
            for i in $(echo $globalSkipFileTypes | sed "s/,/ /g"); do
                FINDSTR+=" -e '\\$i'"
            done
            mvlogger "Global skipfiletypes string: $FINDSTR"
        fi

        if [ -d "$SHAREPATH" ] && ( [ $SHAREUSECACHE != "only" ] || ( [ $SHAREUSECACHE = "only" ] && [ $REPAIRPRIMARYSHARES = "yes" ] )) ; then
            #mvlogger "FINDSTR is: $FINDSTR"
            eval "$FINDSTR>>$FILTERED_FILELIST"
            mvlogger "Updated Filtered filelist: $FILTERED_FILELIST for $SHARENAME"
        fi
        #If overrideFLag set restore settings
        if [ $overrideFlag = 1 ]; then
            overrideFlag=0
            #Get Mover Tuning Settings
            mvlogger "$(titleLine "" '-')"
            mvlogger "Restore global settings"
            mvlogger "-----------------------"
            getMoverSettings $MOVERTUNINGCFGFILE
        fi
    done

    # Sort the file list by cachepoolname, shareusecache, creation/modification time, and inode
    sort -t '|' -k1,1 -k3,3 -k4,4nr -k9,9 -o "$FILTERED_FILELIST" "$FILTERED_FILELIST"

    # Done with populating filtered filelist
}

decideMoveActions () {
    ## Loop Filtered Filelist and for each file decide to move to/from the array
    mvlogger "$(titleLine 'ANALYSING MOVING ACTIONS' '*')"
    mvlogger "Deciding the action (move/sync/keep) for each file. There are $(grep "/mnt" $FILTERED_FILELIST | wc -l) files, it can take a while..."

    ## Proceed with files
    # Fields: $1:CACHEPOOLNAME $2:SHARENAME $3:SHAREUSECACHE $4:MODIFICATIONTIME $5:CACHESIZETRESH 
    # $6:FILESIZE $7SPARSENESS $8:NBLINKS $9:INODE $10:FILEPATH
    awk -F"|" -v AGE="$AGE" -v STATS_FILE="$STATS_FILE" -v SYNCHRONIZECACHE=$SYNCHRONIZECACHE -v LASTCACHESYNC=$LASTCACHESYNC '
        BEGIN {
            # Initialize previous inode and dictionary for pool sums
            previous_inode = 0

            # Print new header
            printf "CACHEPOOLNAME|SHARENAME|SHAREUSECACHE|MODIFICATIONTIME|FILESIZE|POOLSUM|THRESHOLD|NBLINKS|INODE|ACTION|FROM|TO|FILEPATH\n"
        }

        NR > 1 { # Main loop, skip header line

            # Handle hardlink size
            if ($8 > 1) {
                if ($9 == previous_inode) {
                    $6 = 0 # Set filesize to 0 for hardlinks
                }
            }
            previous_inode = $9

            # Update pool sum (use pool_sums[$1])
            pool_sums[$1] += $6

            # Extract the part after the first three slashes in the ninth field
            split($10, path_parts, "/")
            path_in_share = ""
            for (i = 4; i <= length(path_parts); i++) {
                path_in_share = path_in_share path_parts[i]
                if (i < length(path_parts)) {
                    path_in_share = path_in_share "/"
                }
            }
            # Construct full file path
            cachepath = "/mnt/" $1 "/" path_in_share

            # Check where file is stored. Priority to cache in case of dupe
            if (system("[ -e \"" cachepath "\" ]") == 0) {
                # File exists on cache
                filepath = cachepath

                # Make decision to move or keep:
                action = ($3 != "only" && ($3 == "prefer" && (pool_sums[$1] >= $5 && AGE == -1) || AGE >= 0)) ? "move" : "keep"

                if (action == "keep")  {
                    source = "/mnt/" $1
                    if (SYNCHRONIZECACHE == "yes" && $3 != "only" && $4 >= LASTCACHESYNC )  {
                        action = "sync"
                        destination = "/mnt/user0"
                        pool_stats[$1]["files_from_cache"] += 1
                        pool_stats[$1]["total_size_from_cache"] += $6
                    } else {
                        destination = "/mnt/" $1
                    }
                }

                # Update pool statistics and set destination if moving the file
                if (action == "move") {
                    source = "/mnt/" $1
                    destination = "/mnt/user0"
                    pool_stats[$1]["files_from_cache"] += 1
                    pool_stats[$1]["total_size_from_cache"] += $6
                }
            } else {
                # File does not exist on cache

                # Make decision to move or keep:
                action = ($3 == "only" || ($3 == "prefer" && ((pool_sums[$1] <= $5 && AGE == -1) || AGE >= 0))) ? "move" : "keep"

                if (action == "keep") {
                    source = "/mnt/user0"
                    destination = "/mnt/user0"
                }

                # Update pool statistics and set destination if moving the file
                if (action == "move") {
                    source="/mnt/user0"
                    if (SYNCHRONIZECACHE == "yes" && $3 != "only") {
                        action = "sync"
                    }
                    destination = "/mnt/" $1
                    pool_stats[$1]["files_from_array"] += 1
                    pool_stats[$1]["total_size_from_array"] += $6
                }
            }
            # Create action list
            printf "%s|%s|%s|%d|%d|%d|%d|%d|%s|%s|%s|%s|%s\n", $1, $2, $3, $4, $6, pool_sums[$1], $5, $8, $9, action, source, destination, path_in_share
        }
        END {
            # Write statistics header line
            printf "CACHEPOOLNAME|FILES_FROM_CACHE|SIZE_FROM_CACHE|FILES_FROM_ARRAY|SIZE_FROM_ARRAY\n" >> "'"${STATS_FILE}"'"

            # Loop through pool_stats and write data to stats_file
            total_files_from_cache = 0
            total_size_from_cache = 0
            total_files_from_array = 0
            total_size_from_array = 0
            
            for (poolname in pool_stats) {
                files_from_cache = pool_stats[poolname]["files_from_cache"]
                size_from_cache = pool_stats[poolname]["total_size_from_cache"]
                files_from_array = pool_stats[poolname]["files_from_array"]
                size_from_array = pool_stats[poolname]["total_size_from_array"]

                total_files_from_cache += files_from_cache
                total_files_from_array += files_from_array
                total_size_from_cache += size_from_cache
                total_size_from_array += size_from_array
                printf("%s|%d|%d|%d|%d\n", poolname, files_from_cache, size_from_cache, files_from_array, size_from_array) >> "'"${STATS_FILE}"'"
            }

            # Print overall totals to stats file
            printf("TOTAL|%d|%d|%d|%d\n", total_files_from_cache, total_size_from_cache, total_files_from_array, size_from_array) >> "'"${STATS_FILE}"'"

    }' "$FILTERED_FILELIST" > $MOVER_ACTIONLIST

    ## Printing some stats
    TOTALCACHEFILES=$(grep "TOTAL" "$STATS_FILE" | cut -d "|" -f 2)
    TOTALCACHESIZE=$(grep "TOTAL" "$STATS_FILE" | cut -d "|" -f 3)
    TOTALARRAYFILES=$(grep "TOTAL" "$STATS_FILE" | cut -d "|" -f 4)
    TOTALARRAYSIZE=$(grep "TOTAL" "$STATS_FILE" | cut -d "|" -f 5)

    # Add total files and size
    TOTALFILES=$((TOTALCACHEFILES + TOTALARRAYFILES))
    TOTALSIZE=$((TOTALCACHESIZE + TOTALARRAYSIZE))

    # Print stats
    if [ $TOTALFILES -gt 0 ]; then
        mvlogger "A total of $TOTALFILES files representing $TOTALSIZE bytes ($(convert_bytes $TOTALSIZE)) will be moved:"
        if [ $TOTALCACHEFILES -gt 0 ]; then
            # Read data line by line using while loop
            while IFS="|" read -r CACHEPOOLNAME CACHEFILES CACHESIZE ARRAYFILES ARRAYSIZE; do
                if [ -e $SOFTSTOPFILE ]; then
                    echo "Soft Stop requested"
                    mvlogger "Soft Stopping requested"
                    break
                fi
                # Check if line is not the total line nor the header line
                if [ $CACHEPOOLNAME != "TOTAL" ] && [ $CACHEPOOLNAME != "CACHEPOOLNAME" ]; then
                    mvlogger "- $CACHEFILES files representing $CACHESIZE bytes ($(convert_bytes $CACHESIZE)) will be moved/sync from $CACHEPOOLNAME to array"
                fi
            done < "$STATS_FILE"
        else
            mvlogger "- No new files will be moved/synced from cache to array"
        fi
        if [ $TOTALARRAYFILES -gt 0 ]; then
            mvlogger "- $TOTALARRAYFILES new files representing $TOTALARRAYSIZE bytes ($(convert_bytes $TOTALARRAYSIZE)) will then be moved/synced from array to cache"
        else
            mvlogger "- No new files will be moved/synced from array to cache"
        fi
    else
            mvlogger "No new files will be moved/synced from cache to array"
            mvlogger "No new files will be moved/synced from array to cache"
    fi
}

# Internal move engine
processTheMoves () {
    mvlogger "$(titleLine 'LET THE MOVING SHOW BEGIN !' '*')"
    if [ $ENABLETURBO = "yes" ] ; then
        mvlogger "Forcing turbo write on"
        [ $TESTMODE != "yes" ] && /usr/local/sbin/mdcmd set md_write_method 1
    fi
    # MOVER_ACTIONLIST header: 
    # CACHEPOOLNAME|SHARENAME|SHAREUSECACHE|MODIFICATIONTIME|FILESIZE|POOLSUM|THRESHOLD|NBLINKS|INODE|ACTION|FROM|TO|FILEPATH

    # Loop through each line in the action list (except those where action is keep), starting by cache and then array
    for PROCESS_ARRAY in false true; do
        grep -v "|keep|" "$MOVER_ACTIONLIST" | while IFS="|" read -r CACHEPOOLNAME SHARENAME SHAREUSECACHE MODIFICATIONTIME FILESIZE POOLSUM THRESHOLD NBLINKS INODE ACTION SOURCE DESTINATION FILEPATH; do
            if [ -e $SOFTSTOPFILE ]; then
                echo "Soft Stop requested"
                mvlogger "Soft Stopping requested"
                break
            fi

            # Skip header line
            if [ "$ACTION" = "ACTION" ]; then
                continue
            fi

            # Skip if file file not stored on the storage we proceed
            if [ "$PROCESS_ARRAY" = false ] && [ "$SOURCE" = "/mnt/user0" ] || [ "$PROCESS_ARRAY" = true ] && [ "$SOURCE" != "/mnt/user0" ]; then
                continue
            fi

            # Skip filesize = 0 (hardlinks already handeld in a previous loop)
            if [ "$FILESIZE" = 0 ] ; then
                continue
            fi

            #Prepare RSYNC_CMD
            RSYNC_CMD="rsync --archive --xattrs --relative --hard-links"

            if [ $TESTMODE = "yes" ]; then
                RSYNC_CMD+=" --dry-run"
            fi

            # Get files to rsync:
            SYNCED_FILES=$(grep "|$INODE|" $MOVER_ACTIONLIST | cut -d'|' -f13 | while read line; do echo "\"$SOURCE/./$line\""; done | tr '\n' ' ')
            GUI_CURRENT_FILE=$SYNCED_FILES

            # Proceed with rsync
            if [ "$ACTION" = "move" ]; then
                # Some verbosity
                GUI_ACTION="Moving to $DESTINATION/ $([ $NBLINKS -gt 1 ] && echo '(preserving hardlinks)')"
                mvlogger "Moving $SYNCED_FILES to  $DESTINATION/ $([ $NBLINKS -gt 1 ] && echo '(preserving hardlinks)')"
                # Finalize RSYNC_CMD
                RSYNC_CMD+=" --remove-source-files"   
            elif [ "$ACTION" = "sync" ] &&  ([ "$PROCESS_ARRAY" = true ] && [ $SOURCE = "/mnt/user0" ]) ||  ([ "$PROCESS_ARRAY" = false ] && [ $SOURCE != "/mnt/user0" ]) ; then 
                # Some verbosity
                GUI_ACTION="Synchronizing to $DESTINATION/ $([ $NBLINKS -gt 1 ] && echo '(preserving hardlinks)')"
                mvlogger "Synchronizing  $SYNCED_FILES to  $DESTINATION/ $([ $NBLINKS -gt 1 ] && echo '(preserving hardlinks)')"
            else
                continue
            fi

            moverStatusWrite
            # Perform rsync. relative paths and hardlinks
            eval "$RSYNC_CMD" "$SYNCED_FILES" "$DESTINATION/"

            # Setting mover status
            if [ "$SOURCE" == "/mnt/user0" ]; then
                REMAINING_ARRAY_SIZE=$(($REMAINING_ARRAY_SIZE - $FILESIZE))
                REMAINING_ARRAY_FILES=$(($REMAINING_ARRAY_FILES - $NBLINKS))
            else
                REMAINING_CACHE_SIZE=$(($REMAINING_CACHE_SIZE - $FILESIZE))
                REMAINING_CACHE_FILES=$(($REMAINING_CACHE_FILES - $NBLINKS))
            fi
            
            moverStatusWrite

        done
    done

    if grep "|sync|" $MOVER_ACTIONLIST | grep -vq "|sync|/mnt/user0" ; then
        EPOCH=$(date --date="${NOW:0:4}-${NOW:5:2}-${NOW:8:2} ${NOW:11:2}:${NOW:13:2}:${NOW:15:2}" +%s)
        if grep -q "lastCacheSync=" "$MOVERTUNINGCFGFILE"; then
            sed -i "s/lastCacheSync=.*$/lastCacheSync=$EPOCH/" "$MOVERTUNINGCFGFILE"
        else
            echo "lastCacheSync=$EPOCH" >> "$MOVERTUNINGCFGFILE"
        fi
    fi


    if [ $ENABLETURBO = "yes" ] ; then
        turbo_write_mode=$(cat /var/local/emhttp/var.ini | grep "md_write_method=" | cut -d'"' -f2)
        mvlogger "Restoring original turbo write mode $( ( [ $turbo_write_mode = "auto" ] && echo "Auto (read/modify/write)" ) || ( [ $turbo_write_mode -eq 1 ] && echo "Turbo writes (Reconstruct)" ) || echo "Read/modify/write" )"
        [ $TESTMODE != "yes" ] && /usr/local/sbin/mdcmd set md_write_method $turbo_write_mode
    fi
}

start() {
    mvlogger "$(titleLine 'MOVER START' '*')"
    
    # Do not start if already running
    if [ -f $PIDFILE ]; then
        if ps h $(cat $PIDFILE) | grep mover; then
            mvlogger "mover: already running"
            exit 1
        fi
    fi
    echo $$ > $PIDFILE

    #Remove any old /var/run/moversoft.stop files
    if [ -e $SOFTSTOPFILE ]; then
        rm $SOFTSTOPFILE
        mvlogger "Mover soft stop file removed."
    fi

    # Only start if config OK
    if [ -f $UNRAIDCFGFILE ]; then
        if ! grep -qs 'shareCacheEnabled="yes"' $UNRAIDCFGFILE; then
            mvlogger "Fatal error: cache not enabled"
            exit 2
        fi
        if grep -qs 'shareMoverLogging="yes"' $UNRAIDCFGFILE; then
            mvlogger "Log Level: $LOGLEVEL"
        fi
    else 
        mvlogger "Fatal error: $UNRAIDCFGFILE does not exist, check this."
        exit 3
    fi
    if [ -f $MOVERTUNINGCFGFILE ]; then
        #Get Mover Tuning Settings
        mvlogger "$(titleLine "Global settings" '-')"
        getMoverSettings $MOVERTUNINGCFGFILE
    else
        mvlogger "Fatal error: $MOVERTUNINGCFGFILE does not exist, check this."
        exit 6
    fi

    # Only start if cache enabled and present
    if ! grep -qs 'shareCacheEnabled="yes"' $UNRAIDCFGFILE; then
        mvlogger "Fatal error: cache not enabled"
        exit 5
    fi
    if ! mountpoint -q /mnt/user0; then
        mvlogger "Fatal error: cache not present, or only cache present"
        exit 6
    fi

    #Delete helper files over 5 days old.
    find /tmp/ca.mover.tuning/* -daystart -mtime +5 -name '*.list' -delete

    #Delete Mover Log files over 10 days old.
    find /tmp/ca.mover.tuning/* -daystart -mtime +10 -name '*.log' -delete

    #Delete Mover List files with 0 lines.
    find /tmp/ca.mover.tuning/* -size 0 -name '*.list' -delete

    #Let find find hidden files.
    shopt -s nullglob

    #Run mover before script if specified.
    if [ ! -z "$BEFORESCRIPT" ]; then
        if [ -f "$BEFORESCRIPT" ] && [ -x "$BEFORESCRIPT" ]; then
            mvlogger "Launching before script: $BEFORESCRIPT"
            eval \"$BEFORESCRIPT\"
            mvlogger "Before script finished"
#        else
#            mvlogger "Before script file does not exist or is not executable. Skipping."
        fi
    fi

    # Proceed with filter and create filtered filelist and action filelist
    createFilteredFilelist
    decideMoveActions
    # And now.. we move! ... if needed
    if [ $TOTALFILES -gt 0 ]; then
        processTheMoves
    fi

    #Write the final status just for sure
    moverStatusWrite

    rm -f $PIDFILE
    rm -f $SOFTSTOPFILE
 
    #Run mover after script if specified.
    if [ ! -z "$AFTERSCRIPT" ]; then
        if [ -f "$AFTERSCRIPT" ] && [ -x "$AFTERSCRIPT" ]; then
            mvlogger "Launching after script: $AFTERSCRIPT"
            eval \"$AFTERSCRIPT\"
            mvlogger "After script finished with result: $( $? && "OK" || $?)"
        else
            mvlogger "After script file does not exist or is not executable. Skipping."
        fi
    fi
    mvlogger "$(titleLine 'WE ARE DONE !' '*')"
}

killtree() {
    local pid=$1 child

    for child in $(pgrep -P $pid); do
        killtree $child
    done
    [ $pid -ne $$ ] && kill -TERM $pid
}

# Caution: stopping mover like this can lead to partial files on the destination
# and possible incomplete hard link transfer.  Not recommended to do this.
stop() {
    if [ ! -f $PIDFILE ]; then
        echo "mover: not running"
        exit 0
    fi
    killtree $(cat $PIDFILE)
    sleep 2
    rm -f $PIDFILE
    echo "mover: stopped"
    exit
}

softstop() {
    echo "Soft Stop Requested"
    if [ ! -f $PIDFILE ]; then
        echo "mover: not running"
        exit 0
    fi
    touch $SOFTSTOPFILE
    exit
}

status() {
    if [ -f $PIDFILE ]; then
	echo "mover: running"
	cat $PIDFILE
	exit 0
    else
	echo "mover: not running"
    fi
    exit
}

case $1 in
start)
    start
    ;;
stop)
    stop
    ;;
softstop)
    softstop
    ;;
status)
    status
    ;;
*)
    echo "Usage: $0 (start|stop|softstop|status)"
    ;;
esac

# That's all folks :)
